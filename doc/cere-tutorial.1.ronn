cere tutorial(1) -- Example on how to use CERE
====================================================================

## SYNOPSIS

**CERE** is a tool that allows you to capture a region of code and to replay it
whithout running the entire programm. The applications are wide, debugging,
piece wise optimisation and flag exploration, performance prediction...
**CERE** provides automatic process, to profile, capture and replay every
extractible regions of your application and output an html report to visualize
the results.  
This tutorial show and explain how to use **CERE** on BT,
a NAS-SER 3.0 benchmark. We explain for each command what **CERE** is doing,
what are the files generated and their purpose.
You can find BT example in CERE_PATH/example.

## CONFIGURATION OF BT

Once you are in BT folder CERE_PATH/example/NPB3.0-SER/BT/ we have to configure
the application Makefile to use **CERE** for compiling and linking. For the
NAS-SER 3.0 benchmark, this configuration is done in
*CERE_PATH/example/NPB3.0-SER/config/make.def* file.

You should replace F77, FLINK, CC and CLINK values by CERE_PATH/src/ccc/ccc ${MODE}
but it's already done for this example.

*ccc* is a script that apply code transformation (region outlining, region
instrumentation...) using llvm passes. Source files are then compiled with
clang, and the application is linked with gcc.  
MODE tells *ccc* the kind of operation that has to be applied like replay, dump
and the option for each of them.

## CONFIGURATION OF CERE

The first step before using **CERE** on an application is running **cere
configure**. This command tells **CERE** which commands must be used
to build and run the application. Be sure to be in BT folder and type:

```
cere configure --build-cmd="make CLASS=A" --run-cmd="../bin/bt.A"
```

### Output files

    * cere.json: the configuration file. This file is read by most of CERE
    passes. You can manually edit this file.

For more option see also cere-configure(1)

## PROFILE THE APPLICATION

**cere profile** is used to determine the application runtime and the percentage
of execution time for each extractible region using Google perf tool. This
command also generate the region call graph. 

### Measuring application runtime

To measure the programm runtime, we instrument the application. Probes are
inserted at the very beginning of the main function and at the application
exit. RDTSC is used to count CPU cycles between these two probes. To run only
the application runtime measure, type:

`
cere profile --app
`

**Output file:**
    * .cere/profile/app_cycles.csv: the application runtime in CPU cycles.

### Region instrumentation

Two important steps in **CERE** are, determine regions that are worth to
extract/replay, and build the region call graph. This is done using the Google
perf tool. The CPU profiler of the Google perf tool instrument every functions
and gives for each of them usefull informations like the overall coverage, the
self coverage, calls between function and more.
To do so, **CERE** first outline every region in functions and run the CPU
profiler. The output is then parsed with *pprof* to generate the intern
representation of the call graph.

`
cere profile --regions
`

**Output files:**
    * .cere/profile/app.prof: the google perf tool output.
    * .cere/profile/graph_.dot: dot representation of the region call graph.
    * .cere/profile/graph_.pdf: image of the call graph.
    * .cere/profile/graph_.pkl: the python graph object.

The graph you obtain should look like the one in CERE_PATH/doc/images/graph_.pdf

### Full profiling

To generate the full profiling type:

```
cere profile
```

For more option see also cere-profile(1)

## LIST EXTRACTIBLE REGIONS

With **cere profile --regions** you can already have a visual idea of what are
the important regions in your application. But you can also list them in a file.
With the command:

**cere regions**

**Output files:**
    * regions.csv: File containing for each region, the region name, region
    location, and coverage informations.

For more option see also cere-regions(1)

## AUTOMATIC SELECTORS

One of main **CERE** goal is to provide a set of codelets that represent the best
the application.  
**CERE** can automatically select the best regions depending on what you want.
**CERE** provide two selectors:

1. select-max-cov: this selector choose the best regions to maximise the application
coverage with codelets. This method maximise the coverage regardless replay cost.
2. select-ilp: this selector also choose regions to maximise the coverage but with a constraint:
we can't select nested regions. This method gives the best coverage while minimizing
the replay cost.

For both selectors, the process is the same:

1. **CERE** choose in the graph generated by the profiling pass a set of
interesting regions. Interesting regions are by default regions with coverage
greater than 1%. This threshold is configurable.
2. **CERE** extract and replay the choosen regions. For each region, the error
between the replay and the original execution is calculated. By default if this
error is lower than 15% we consider this region as a valid one. This threshold is
also configurable.
3. The graph is updated, and the process restart at step 1.

### Use select-max-cov

```
cere select-max-cov
```

### Use select-ilp

```
cere select-ilp
```

You can find more information in cere-select-max-cov(1) and cere-select-ilp(1)

## CERE REPORT

**CERE** provides a report tool to visualize in html format several informations
about the extraction process for your application. You can find an example of
report for BT in CERE_PATH/doc/images/BT_report.html.
To generate the report:

**cere report**

**Output files:**
    * BT.html: The report of the selection process.

## GO FURTHER

Coming soon

## COPYRIGHT

cere is Copyright (C) 2014-2015 Universit√© de Versailles St-Quentin-en-Yvelines

## SEE ALSO

cere-trace(1) cere-capture(1) cere-replay(1)
