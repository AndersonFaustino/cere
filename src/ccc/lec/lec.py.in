#!/usr/bin/env python
# This file is part of CERE.
#
# Copyright (c) 2013-2015, Universite de Versailles St-Quentin-en-Yvelines
#
# CERE is free software: you can redistribute it and/or modify it under
# the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License,
# or (at your option) any later version.
#
# CERE is distributed in the hope that it will be useful,  
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with CERE.  If not, see <http://www.gnu.org/licenses/>.  
import os

PROJECT_ROOT = os.path.dirname(os.path.realpath(__file__+"/../.."))
LOOP_EXT = "/RegionOutliner/.libs/libRegionOutliner.so"
LOOP_DUMP = "/RegionDump/.libs/libRegionDump.so"
LOOP_REPLAY = "/RegionReplay/.libs/libRegionReplay.so"
LOOP_INSTR = "/RegionInstrumentation/.libs/libRegionInstrumentation.so"
LLVM_BINDIR = "@LLVM_BINDIR@"
DRAGONEGG_PATH = "@DRAGONEGG_PATH@"
GCC="@GCC_PATH@"
FORTRAN_EXTENSIONS=[".f", ".f90", ".f77"]
SOURCE_EXTENSIONS=[".C", ".c", ".cpp", ".cc"] + FORTRAN_EXTENSIONS
OMP_FLAGS=""
if "CERE_OMP" in os.environ:
    OMP_FLAGS="-omp"
BACKEND_FLAGS=""
if "CERE_BACKEND_FLAGS" in os.environ:
    BACKEND_FLAGS=os.environ["CERE_BACKEND_FLAGS"]

def fail_lec(error_message):
    exit("Error {prog} : {cmd}".format(prog='lec', cmd=error_message))

def safe_system(command, EXIT=True):
    '''
    Try-catch system call
    Verify system call and exit with appropriate error message
    '''
    if(os.system(command)):
        if (EXIT):
            fail_lec("safe_system -> " + command)
        else:
            print("Warning Error {prog} : safe_system -> {cmd}".format(
                  prog='lec', cmd=command))

def dump_fun(mode_opt, BASE):
    '''
    Dump mode
    Call LoopExtractor and LoopManager in dump mode on wanted loops
    by passing options like --invocation
    In link mode: Call the linker and copy the original binary
    '''
    temp = ""
    print "Compiling dump mode"
    if(mode_opt.region):
        temp = " --region="+mode_opt.region+" "
        if(mode_opt.regions_file):
            fail_lec("--regions-file and --region are incompatible")
    else:
        if(mode_opt.regions_file):
            temp = temp+"--regions-file="+mode_opt.regions_file+" "
    if(mode_opt.invocation):
        temp = temp+"--invocation="+mode_opt.invocation+" "
    safe_system(("{llvm_bindir}/opt -S -load {Root}{LoopExt} {Omp}-region-outliner " +
                "{base}.ll -o {base}.ll").format(llvm_bindir=LLVM_BINDIR, Root=PROJECT_ROOT,
                LoopExt=LOOP_EXT, base=BASE,Omp=OMP_FLAGS), EXIT=False)
    safe_system(("{llvm_bindir}/opt -S -load {Root}{LoopMan} {Omp}-region-dump {opts} " +
                "{base}.ll -o {base}.ll").format(llvm_bindir=LLVM_BINDIR, Root=PROJECT_ROOT,
                LoopMan=LOOP_DUMP, opts=temp, base=BASE,Omp=OMP_FLAGS), EXIT=False)

#in replay mode
def replay_fun(mode_opt, BASE):
    '''
    Replay mode
    Call LoopExtractor and LoopManager in replay mode on wanted loop
    by passing options like --invocation
    '''
    temp = ""
    if (not (mode_opt.region)):
        fail_lec("Need --region with replay mode")
    print "Compiling replay mode"
    if (mode_opt.invocation):
        temp = temp + "--invocation=" + mode_opt.invocation + " "
    safe_system(("{llvm_bindir}/opt -S -load {Root}{LoopExt} {Omp}-region-outliner " +
                "-isolate-region={loop} {base}.ll -o {base}.ll").format(
                llvm_bindir=LLVM_BINDIR, Root=PROJECT_ROOT, LoopExt=LOOP_EXT,
                loop=mode_opt.region, base=BASE,Omp=OMP_FLAGS), EXIT=False)
    safe_system(("{llvm_bindir}/opt -S -load {Root}{LoopMan} {opts} {Omp}-region-replay -region={loop} " +
                "{base}.ll -o {base}.ll").format(llvm_bindir=LLVM_BINDIR,
                    Root=PROJECT_ROOT, LoopMan=LOOP_REPLAY, opts=temp, loop=mode_opt.region,
                    base=BASE,Omp=OMP_FLAGS), EXIT=False)
    if (mode_opt.instrument):
        print "Instrumentation mode"
        temp_instr = "--instrument-region=" + mode_opt.region + " "
        safe_system(("{llvm_bindir}/opt -S -loop-simplify {base}.ll -o {base}.ll").format(
                    llvm_bindir=LLVM_BINDIR,
                    base=BASE), EXIT=False)
        safe_system(("{llvm_bindir}/opt -S -load {Root}{LoopInstr} " +
                    "{Omp}-region-instrumentation --replay {opts} {base}.ll " +
                    "-o {base}.ll").format(
                    llvm_bindir=LLVM_BINDIR, Root=PROJECT_ROOT,
                    LoopInstr=LOOP_INSTR, opts=temp_instr, base=BASE,Omp=OMP_FLAGS),
                    EXIT=False)

    #When inside the compilation unit that contains the replayable
    #code internal symbols should be globalized XXX: An LLVM pass
    #would be preferable than the ugly sed hack below.
    if BASE in mode_opt.region:
        os.system("sed -i 's/internal global/global/' {base}.ll".format(base=BASE))

#in original mode
def original_fun(mode_opt, BASE):
    '''
    Original mode
    Call LoopInstrumentation on wanted loops
    by passing options like --invocation
    '''
    instru_opts = ""
    extract_opts = ""
    if(mode_opt.region):
        instru_opts = instru_opts + "--instrument-region=" + mode_opt.region + " "
        if(mode_opt.regions_file):
            fail_lec("--regions-file and --region are incompatible")
        if(mode_opt.invocation):
            instru_opts = instru_opts + "--invocation=" + mode_opt.invocation + " "
        if(mode_opt.instrument_app):
            fail_lec("--instrument-app and --region are incompatible")
    else:
        if(mode_opt.invocation):
            fail_lec("Can't measure specific invocation with --regions-file")
        if(mode_opt.regions_file):
            instru_opts = instru_opts + "--regions-file=" + mode_opt.regions_file + " "
            if(mode_opt.instrument_app):
                fail_lec("--regions-file and --instrument-app are incompatible")
            if(mode_opt.invocation):
                fail_lec("--regions-file and --invocation are incompatible")
        else:
            if(mode_opt.instrument_app):
                extract_opts = extract_opts + "--instrument-app "
            else:
                instru_opts = instru_opts + "--instrument-app "
    if(mode_opt.instrument):
        if(mode_opt.instrument_app):
            safe_system(("{llvm_bindir}/opt -S -load {Root}{LoopExt} {Omp}-region-outliner {opts} " +
                "{base}.ll -o {base}.ll").format(llvm_bindir=LLVM_BINDIR, Root=PROJECT_ROOT,
                LoopExt=LOOP_EXT, opts=extract_opts, base=BASE,Omp=OMP_FLAGS), EXIT=False)
        else:
            safe_system(("{llvm_bindir}/opt -S -load {Root}{LoopInstr} " +
                        "{Omp}-region-instrumentation {opts} {base}.ll " +
                        "-o {base}.ll").format(
                        llvm_bindir=LLVM_BINDIR, Root=PROJECT_ROOT,
                        LoopInstr=LOOP_INSTR, opts=instru_opts, base=BASE,Omp=OMP_FLAGS, EXIT=False))

def first_compil(INCLUDES, SOURCE, BASE, ext, COMPIL_OPT):
    '''
    First Compilation
    Detect source language (fortran or C/C++ for the moment)
    and compile SOURCE code
    '''
    if ext in FORTRAN_EXTENSIONS:
        if DRAGONEGG_PATH:
            safe_system(("{gcc} {opts} -O0 -g {includes} {source} -S " +
                        "-fplugin={dragonegg} -fplugin-arg-dragonegg-emit-ir -o {base}.ll").format(
                        gcc=GCC, opts=" ".join(COMPIL_OPT), includes=" ".join(INCLUDES), source=SOURCE,
                        Root=PROJECT_ROOT, dragonegg=DRAGONEGG_PATH, base=BASE))
        else:
            fail_lec("fortran support disabled. Please reconfigure using --with-dragonegg.")
    else:
        safe_system(("{llvm_bindir}/clang {opts} -O0 -g {includes} {source} -S -emit-llvm -o " +
                    "{base}.ll").format(llvm_bindir=LLVM_BINDIR, opts=" ".join(COMPIL_OPT), includes=" ".join(INCLUDES),
                    source=SOURCE, base=BASE))

def last_compil(INCLUDES, SOURCE, BASE, OBJECT, COMPIL_OPT):
    '''
    Last Compilation
    Compile BASE.ll
    If Error compile with INCLUDES
    '''
    test = os.system("{llvm_bindir}/clang -c {opts} {backend_flags} {base}.ll -o {object}".format(
                     llvm_bindir=LLVM_BINDIR, opts=" ".join(COMPIL_OPT),
                     backend_flags=BACKEND_FLAGS, base=BASE, object=OBJECT))

    if (test):
        safe_system("{llvm_bindir}/clang -c {opts} {includes} {source} -o {object}".format(
                    llvm_bindir=LLVM_BINDIR, opts=" ".join(COMPIL_OPT), includes=" ".join(INCLUDES),
                    source=SOURCE, base=BASE, object=OBJECT))

def compile(args, args2):
    function={}
    function["replay_fun"] = replay_fun
    function["dump_fun"] = dump_fun
    function["original_fun"] = original_fun
    SOURCES = []
    if (len(args2[1]) == 0):
        exit("Error:Need source file")
    INCLUDES = args2[0].Inc
    COMPIL_OPT = []
    for source in args2[1]:
        if os.path.splitext(source)[1] in SOURCE_EXTENSIONS:
            SOURCES.append(source)
        else: COMPIL_OPT.append(source)

    for SOURCE in SOURCES:
        BASE, ext = os.path.splitext(SOURCE)
        OBJECT = args[0].o if args[0].o else BASE + '.o'
        # call mode_function
        first_compil(INCLUDES, SOURCE, BASE, ext, COMPIL_OPT)
        function[args[0].func](args[0], BASE)
        last_compil(INCLUDES, SOURCE, BASE, OBJECT, COMPIL_OPT)
