#!/usr/bin/env python
# Loop Extractor Compiler
# (C) 2013 University of Versailles
import os
import re
import argparse
import tempfile

ROOT = os.path.dirname(os.path.realpath(__file__))
PROJECT_ROOT = os.path.dirname(os.path.realpath(__file__+"/../.."))
RDTSC = "/rdtsc/librdtsc.a"
LIKWID = "/usr/local/lib/liblikwid.a -lpthread -lm"
PROFILE_LIB = "-lprofiler"
MEMORYDUMP = "/memory_dump/.libs/"
VERSION = "@PACKAGE_VERSION@"
LD="gcc-4.7"

def grep(path, regex):
    regex=".*"+regex+".*"
    regObj = re.compile(regex)
    res = []
    for root, dirs, fnames in os.walk(path):
        for fname in fnames:
            if fname.endswith(".ll"):
                with open(fname, "r") as f:
                    for line in f.readlines():
                        if regObj.match(line):
                            res.append(os.path.join(root, fname))
    return res

def fail_lel(error_message):
    exit("Error {prog} : {cmd}".format(prog='lel', cmd=error_message))

def safe_system(command):
    '''
    Try-catch system call
    Verify system call and exit with appropriate error message
    '''
    if(os.system(command)):
        fail_lel("safe_system -> " + command)

def user_main(FILE, LOOP, mode_opt):
    # Define by default TIMEOUT_SECONDS to 60
    TIMEOUT_SECONDS=os.getenv('TIMEOUT_SECONDS', 60) #1min is probably enough
    # Define by default CALL_COUNT to 11
    INVITRO_CALL_COUNT=os.getenv('INVITRO_CALL_COUNT', 11)
    temp_init=""
    temp_close=""
    if (mode_opt.instrument):
        temp_init = "cere_markerInit(\"{0}\");\n".format(mode_opt.tool)
        temp_close = "cere_markerClose(\"{0}\");\n".format(mode_opt.tool)
    TEMPLATE = open("{root}/Template_realmain.c".format(root=ROOT), "r")
    template = TEMPLATE.read()
    TEMPLATE.close()
    FILE.write(template.format(time_out=TIMEOUT_SECONDS, instru_init=temp_init,
               instru_close=temp_close, in_vitro_call_count=INVITRO_CALL_COUNT,
               loop=LOOP.replace("-","_")))

def create_user_main(mode_opt,LOOP):
    safe_system("rm -f realmain.c")
    MAIN=open('realmain.c','w')
    user_main(MAIN, LOOP, mode_opt)
    MAIN.close()

def instrumentation(INSTRU, mode_opt):
    cere_init=""
    cere_close=""
    cere_start=""
    cere_stop=""
    if (mode_opt.tool == "rdtsc"):
        cere_init="rdtsc_markerInit();\n"
        cere_close="rdtsc_markerClose();\n"
        cere_start="rdtsc_markerStartRegion(regName, trace, global);\n"
        cere_stop="rdtsc_markerStopRegion(regName, trace, global);\n"
    elif(mode_opt.tool == "likwid"):
        cere_init="likwid_markerInit();\n"
        cere_close="likwid_markerClose();\n"
        cere_start="likwid_markerStartRegion(regName);\n"
        cere_stop="likwid_markerStopRegion(regName);\n"
    else:
        fail_lel("Unknown tool {0}".format(mode_opt.tool))
    TEMPLATE = open("{root}/instrumentation_wrapper.c".format(root=ROOT), "r")
    template = TEMPLATE.read()
    TEMPLATE.close()
    INSTRU.write(template.format(cere_init=cere_init, cere_close=cere_close,
                        cere_start=cere_start, cere_stop=cere_stop))

def create_instrumentation_wrapper(mode_opt):
    safe_system("rm -f instrumentation_wrapper.c")
    INSTRU=open('instrumentation_wrapper.c', 'w')
    instrumentation(INSTRU, mode_opt)
    INSTRU.close()

def compile_memory_dump_objects(DIR):
    DUMP_ARGS="-Wl,--section-start=.text=0x60000000"
    safe_system("rm -f cere_dumps/objs.S")
    OBJ=open("cere_dumps/objs.S",'w')
    for FILE in os.listdir(DIR):
        BASE, ext = os.path.splitext(FILE)
        FILE = DIR+"/"+FILE
        if (ext=='.memdump'):
            OBJ.write((".section s{n}, \"aw\"\n" +
                       ".incbin \"{m}\"\n").format(n=BASE,m=FILE))
            DUMP_ARGS = (DUMP_ARGS +
                        " -Wl,--section-start=s{n}=0x{n}".format(n=BASE))
    OBJ.close()
    safe_system(LD + " -c cere_dumps/objs.S")
    return DUMP_ARGS

def dump_fun(mode_opt, BINARY, COMPIL_OPT):
    '''
    Dump mode
    Call the linker and copy the original binary
    '''
    safe_system(("{ld} {opts} -o {binary} -L {Root}{libs} -ldump -Wl," +
                "--rpath={Root}{libs} -ldl").format(ld=LD, binary=BINARY,
                opts=COMPIL_OPT, Root=PROJECT_ROOT,libs=MEMORYDUMP))

#in replay mode
def replay_fun(mode_opt, BINARY, COMPIL_OPT):
    '''
    Replay mode
    Create Realmain and call the linker
    '''
    LOOP=mode_opt.region
    INVOCATION=mode_opt.invocation
    instru_wrapper=""
    if (mode_opt.instrument):
        create_instrumentation_wrapper(mode_opt)
        if (mode_opt.tool == "rdtsc"):
            COMPIL_OPT = COMPIL_OPT + " " + PROJECT_ROOT + RDTSC + " "
        elif(mode_opt.tool == "likwid"):
            COMPIL_OPT = COMPIL_OPT + " " + LIKWID + " "
        else:
            fail_lel("Unknown tool {0}".format(mode_opt.tool))
        safe_system(LD + " -c instrumentation_wrapper.c")
        instru_wrapper = "instrumentation_wrapper.o"
    if(not INVOCATION):
        INVOCATION=1
    DIR="cere_dumps/{loop}/{invocation}".format(loop=LOOP,invocation=INVOCATION)
    # Check that dumps exists
    if (not os.path.isdir(DIR)):
        fail_lel("No dump for {loop} invocation {invocation}".format(loop=LOOP,
                 invocation=INVOCATION))
    # Compress the traces
    safe_system("{root}/compress.py {rep}/".format(root=ROOT, rep=DIR))
    create_user_main(mode_opt,LOOP)
    
    safe_system(LD + " -c realmain.c")
    OPTS = compile_memory_dump_objects(DIR)
    with tempfile.NamedTemporaryFile() as f:
        f.write(("{opts} -o {binary} objs.o realmain.o {wrapper} {args} " +
                "-L {Root}{libs} -lload -Wl," +
                "--rpath={Root}{libs} -ldl\n").format(
                ld=LD, opts=OPTS, binary=BINARY, args=COMPIL_OPT,
                Root=PROJECT_ROOT,libs=MEMORYDUMP,wrapper=instru_wrapper))
        f.flush()
        safe_system(("{ld} @{tempfile}".format(tempfile=f.name, ld=LD)))
    safe_system(("{root}/staticpatcher.py {dump_dir}/lel_bin {binary} " +
                "{loop}/{invocation}").format(root=ROOT, dump_dir=DIR,
                binary=BINARY, loop=LOOP, invocation=INVOCATION))

#in original mode
def original_fun(mode_opt, BINARY, COMPIL_OPT):
    '''
    Original mode
    Only call the linker
    '''
    if(mode_opt.instrument_app):
        safe_system(("{ld} -o {binary} {opts} {libs}").format(ld=LD,
                binary=BINARY, opts=COMPIL_OPT, libs=PROFILE_LIB))
    elif(mode_opt.instrument):
        INSTRU=""
        create_instrumentation_wrapper(mode_opt)
        if (mode_opt.tool == "rdtsc"):
            INSTRU = PROJECT_ROOT + RDTSC + " "
        elif(mode_opt.tool == "likwid"):
            INSTRU = LIKWID + " "
        safe_system(LD + " -c instrumentation_wrapper.c")
        safe_system(("{ld} -o {binary} instrumentation_wrapper.o {opts} {instru}").format(ld=LD,
                binary=BINARY, opts=COMPIL_OPT, instru=INSTRU))
    else:
        safe_system(("{ld} -o {binary} {opts}").format(ld=LD,
                binary=BINARY, opts=COMPIL_OPT))

def link(args):
    function={}
    function["replay_fun"] = replay_fun
    function["dump_fun"] = dump_fun
    function["original_fun"] = original_fun
    if (len(args[1]) == 0):
        exit("Error:Need source file")
    COMPIL_OPT = " ".join(args[1])
    BINARY = args[0].o
    # call mode_function
    function[args[0].func](args[0], BINARY, COMPIL_OPT)
