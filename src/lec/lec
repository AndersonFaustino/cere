#!/bin/bash
# Loop Extractor Compiler
# (C) 2013 University of Versailles

ROOT="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PROJECT_ROOT="$ROOT/../../"

# parse arguments
if [[ $1 == --replay=* ]]; then
    SPLIT=(${1//=/ })
    REPLAY_LOOP=${SPLIT[1]}
    echo "Compiling replay mode" > /dev/stderr
    shift
    if [[ $1 =~ --invocation=* ]]; then
        REPLAY_OPTS=$1
        shift
    fi
fi 

if [[ $1 == --dump ]]; then
    DUMP_MODE=1
    echo "Compiling dump mode" > /dev/stderr
    shift
    if [[ $1 =~ --loop-to-dump=* ]] || [[ $1 =~ --loops-file=* ]]; then
        DUMP_OPTS=$1
        shift
    fi
    if [[ $1 =~ --invocation=* ]]; then
        DUMP_OPTS="$DUMP_OPTS $1"
        shift
    fi
fi

if [[ $1 =~ --instrument ]]; then
    INSTRUMENT=1
    shift
    echo "Instrumentation mode" > /dev/stderr
    if [[ $1 =~ --instrument-loop=* ]] || [[ $1 =~ --loops-file=* ]]; then
        INSTRU_OPTS=$1
        shift
    fi
    if [[ $1 =~ --loop-to-trace=* ]]; then
        echo "Trace mode" > /dev/stderr
        INSTRU_OPTS="$INSTRU_OPTS $1"
        shift
    fi
fi
    
    

if [[ ! -z "$DUMP_MODE" && ! -z "$INSTRUMENT" ]]; then
    INSTRUMENT=0
    echo "--instrument ignored, can't instrument in dump mode"
fi

SOURCE=${!#} #last parameter
BASE=${SOURCE%.*}
#includes (-I) and defines (-D) must be detected here
#for compilation from source to IR
for var in "${@:1:$(($#-1))}"
do
    if [[ $var == -I*  || $var == -D* ]]; then
        INCLUDES="$INCLUDES $var"
    else
        OPTS="$OPTS $var"
    fi
done

# Detect source language (fortran or C/C++ for the moment)
if [[ $SOURCE == *.f ]] || [[ $SOURCE == *.f90 ]] || [[ $SOURCE == *.F90 ]] || [[ $SOURCE == *.F ]]; then
    gcc-4.7 -O0 -g -c $INCLUDES $SOURCE -S -fplugin=$PROJECT_ROOT/libs/dragonegg-3.3.src/dragonegg.so -fplugin-arg-dragonegg-emit-ir -o $BASE.ll
else
    clang -O0 -g -c $INCLUDES $SOURCE -S -emit-llvm -o $BASE.ll
fi 

if [ "$?" != "0" ]; then
    exit 1
fi

    

if [[ ! -z "$DUMP_MODE" ]]; then
    # In dump mode
    opt -S -load $PROJECT_ROOT/src/LoopExtractorAll/.libs/libLoopExtractorAll.so -loop-extract-all $BASE.ll -o $BASE.ll
    opt -S -load $PROJECT_ROOT/src/LoopManager/.libs/libLoopManager.so -loop-dump $DUMP_OPTS $BASE.ll -o $BASE.ll

elif [[ ! -z "$REPLAY_LOOP" ]]; then
    # In replay mode 
    opt -S -load $PROJECT_ROOT/src/LoopExtractorAll/.libs/libLoopExtractorAll.so -loop-extract-all -isolate-loop=${REPLAY_LOOP} $BASE.ll -o $BASE.ll
    opt -S -load $PROJECT_ROOT/src/LoopManager/.libs/libLoopManager.so -loop-replay ${REPLAY_OPTS} $BASE.ll -o $BASE.ll
fi

if [[ ! -z "$INSTRUMENT" ]]; then
    opt -S -loop-simplify $BASE.ll -o $BASE.ll
    if [[ ! -z "$REPLAY_LOOP" ]]; then
        opt -S -load $PROJECT_ROOT/src/LoopInstrumentation/.libs/libLoopInstrumentation.so -vitro-loop-instrumentation -instrument-loop=${REPLAY_LOOP} ${INSTRU_OPTS} $BASE.ll -o $BASE.ll
    else
        opt -S -load $PROJECT_ROOT/src/LoopInstrumentation/.libs/libLoopInstrumentation.so -vivo-loop-instrumentation ${INSTRU_OPTS} $BASE.ll -o $BASE.ll
    fi
fi

clang -c $OPTS $BASE.ll -o $BASE.o
if [ "$?" != "0" ]; then
    clang -c $OPTS $INCLUDES $SOURCE -o $BASE.o
fi
