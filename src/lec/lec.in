#!/usr/bin/env python
# Loop Extractor Compiler
# (C) 2013 University of Versailles
import os
import argparse
import tempfile

#to ignore prefix matching
class MyParser(argparse.ArgumentParser):
    def _get_option_tuples(self, option_string):
        return []

ROOT = os.path.dirname(os.path.realpath(__file__))
PROJECT_ROOT = os.path.dirname(os.path.realpath(__file__+"/../.."))
LOOP_EXT = "/src/LoopExtractorAll/.libs/libLoopExtractorAll.so"
LOOP_MANAGE = "/src/LoopManager/.libs/libLoopManager.so"
LOOP_INSTR = "/src/LoopInstrumentation/.libs/libLoopInstrumentation.so"
RDTSC = "/src/rdtsc/librdtsc.a"
PROFILE_LIB = "-lprofiler"
MEMORYDUMP = "/src/memory_dump/.libs/"
VERSION = "@PACKAGE_VERSION@"
LLVM_BINDIR = "@LLVM_BINDIR@"
DRAGONEGG_PATH = "@DRAGONEGG_PATH@"
LD="gcc-4.7"
SOURCE_EXTENSIONS=[".c", ".cpp", ".cc", ".f", ".f90", ".f77"]
FORTRAN_EXTENSIONS=[".f", ".f90", ".f77"]
#Allowed options
option_forbidden = set([("dump", "--trace"),
                       ("dump", "--instrument"),
                       ("dump", "--nested-regions"),
                       ("dump", "--no-nested-regions"),
                       ("dump", "--instrument-app"),
                       ("replay", "--regions-file"),
                       ("replay", "--nested-regions"),
                       ("replay", "--no-nested-regions"),
                       ("replay", "--instrument-app"),
                       ("original", "--invocation")])

#Allowed option verification
class OptAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        if (parser.description, option_string) in option_forbidden:
            exit("Error:can't {option} in {mode} mode".format(
                 option=option_string, mode=parser.description))
        else:
            if (self.const):
                setattr(namespace, self.dest, self.const)
            else:
                setattr(namespace, self.dest, values)

def fail_lec(error_message):
    exit("Error {prog} : {cmd}".format(prog='lec', cmd=error_message))

def safe_system(command, EXIT=True):
    '''
    Try-catch system call
    Verify system call and exit with appropriate error message
    '''
    if(os.system(command)):
        if (EXIT):
            fail_lec("safe_system -> " + command)
        else:
            print("Warning Error {prog} : safe_system -> {cmd}".format(
                  prog='lec', cmd=command))

def user_main(FILE, LOOP, instrument):
    # Define by default TIMEOUT_SECONDS to 60
    TIMEOUT_SECONDS=os.getenv('TIMEOUT_SECONDS', 60) #1min is probably enough
    # Define by default CALL_COUNT to 11
    INVITRO_CALL_COUNT=os.getenv('INVITRO_CALL_COUNT', 11)
    if (instrument):
        temp = "rdtsc_markerInit();\n"
    else:
        temp=""
    TEMPLATE = open("{root}/Template_realmain.c".format(root=ROOT), "r")
    template = TEMPLATE.read()
    TEMPLATE.close()
    FILE.write(template.format(time_out=TIMEOUT_SECONDS, rdtsc=temp,
               in_vitro_call_count=INVITRO_CALL_COUNT,
               loop=LOOP.replace("-","_")))

def create_user_main(Instrument,LOOP):
    safe_system("rm -f realmain.c")
    MAIN=open('realmain.c','w')
    user_main(MAIN, LOOP, Instrument)
    MAIN.close()

def compile_memory_dump_objects(DIR):
    DUMP_ARGS="-Wl,--section-start=.text=0x60000000"
    safe_system("rm -f cere_dumps/objs.S")
    OBJ=open("cere_dumps/objs.S",'w')
    for FILE in os.listdir(DIR):
        BASE, ext = os.path.splitext(FILE)
        FILE = DIR+"/"+FILE
        if (ext=='.memdump'):
            OBJ.write((".section s{n}, \"aw\"\n" +
                       ".incbin \"{m}\"\n").format(n=BASE,m=FILE))
            DUMP_ARGS = (DUMP_ARGS +
                        " -Wl,--section-start=s{n}=0x{n}".format(n=BASE))
    OBJ.close()
    safe_system(LD + " -c cere_dumps/objs.S")
    return DUMP_ARGS

def dump_fun(mode_opt, BASE, COMPIL_OPT, MODE):
    '''
    Dump mode
    Call LoopExtractor and LoopManager in dump mode on wanted loops
    by passing options like --invocation
    In link mode: Call the linker and copy the original binary
    '''
    if MODE=="compilation":
        temp = ""
        print "Compiling dump mode"
        if(mode_opt.region):
            temp = temp+"--loop-to-dump="+mode_opt.region+" "
            if(mode_opt.regions_file):
                fail_lec("--regions-file and --region are incompatible")
        else:
            if(mode_opt.regions_file):
                temp = temp+"--loops-file="+mode_opt.regions_file+" "
        if(mode_opt.invocation):
            temp = temp+"--invocation="+mode_opt.invocation+" "
        safe_system(("{llvm_bindir}/opt -S -load {Root}{LoopExt} -loop-extract-all " +
                    "{base}.ll -o {base}.ll").format(llvm_bindir=LLVM_BINDIR, Root=PROJECT_ROOT,
                    LoopExt=LOOP_EXT, base=BASE), EXIT=False)
        safe_system(("{llvm_bindir}/opt -S -load {Root}{LoopMan} -loop-dump {opts} " +
                    "{base}.ll -o {base}.ll").format(llvm_bindir=LLVM_BINDIR, Root=PROJECT_ROOT,
                    LoopMan=LOOP_MANAGE, opts=temp, base=BASE), EXIT=False)
    else:
        safe_system(("{ld} {opts} -o {binary} -L {Root}{libs} -ldump -Wl," +
                    "--rpath={Root}{libs} -ldl").format(ld=LD, binary=BASE,
                    opts=COMPIL_OPT, Root=PROJECT_ROOT,libs=MEMORYDUMP))

#in replay mode
def replay_fun(mode_opt, BASE, COMPIL_OPT, MODE):
    '''
    Replay mode
    Call LoopExtractor and LoopManager in replay mode on wanted loop
    by passing options like --invocation
    '''
    if MODE=="compilation":
        temp = ""
        if (not (mode_opt.region)):
            fail_lec("Need --region with replay mode")
        print "Compiling replay mode"
        if (mode_opt.invocation):
            temp = temp + "--invocation=" + mode_opt.invocation + " "
        safe_system(("{llvm_bindir}/opt -S -load {Root}{LoopExt} -loop-extract-all " +
                    "-isolate-loop={loop} {base}.ll -o {base}.ll").format(
                    llvm_bindir=LLVM_BINDIR, Root=PROJECT_ROOT, LoopExt=LOOP_EXT,
                    loop=mode_opt.region, base=BASE), EXIT=False)
        safe_system(("{llvm_bindir}/opt -S -load {Root}{LoopMan} -loop-replay {opts} " +
                    "{base}.ll -o {base}.ll").format(llvm_bindir=LLVM_BINDIR,
                        Root=PROJECT_ROOT, LoopMan=LOOP_MANAGE, opts=temp,
                        base=BASE), EXIT=False)
        if (mode_opt.instrument):
            print "Instrumentation mode"
            temp_instr = "--instrument-loop=" + mode_opt.region + " "
            if(mode_opt.trace):
                print "Trace mode"
                temp_instr = (temp_instr + "--loop-to-trace="
                              + mode_opt.region + " ")
            safe_system(("{llvm_bindir}/opt -S -loop-simplify {base}.ll -o {base}.ll").format(
                        llvm_bindir=LLVM_BINDIR,
                        base=BASE), EXIT=False)
            safe_system(("{llvm_bindir}/opt -S -load {Root}{LoopInstr} " +
                        "-vitro-loop-instrumentation {opts} {base}.ll " +
                        "-o {base}.ll").format(
                        llvm_bindir=LLVM_BINDIR, Root=PROJECT_ROOT,
                        LoopInstr=LOOP_INSTR, opts=temp_instr, base=BASE),
                        EXIT=False)
    else:
        LOOP=mode_opt.region
        INVOCATION=mode_opt.invocation
        if (mode_opt.instrument):
            COMPIL_OPT = PROJECT_ROOT + RDTSC + " " + COMPIL_OPT
        if(not INVOCATION):
            INVOCATION=1
        DIR="cere_dumps/{loop}/{invocation}".format(loop=LOOP,invocation=INVOCATION)
        # Check that dumps exists
        if (not os.path.isdir(DIR)):
            fail_lec("No dump for {loop} invocation {invocation}".format(loop=LOOP,
                     invocation=INVOCATION))
        # Compress the traces
        safe_system("{root}/compress.py {rep}/".format(root=ROOT, rep=DIR))
        create_user_main(mode_opt.instrument,LOOP)
        safe_system(LD + " -c realmain.c")
        OPTS = compile_memory_dump_objects(DIR)
        with tempfile.NamedTemporaryFile() as f:
            f.write(("{opts} -o {binary} objs.o realmain.o {args} " +
                    "-L {Root}{libs} -lload -Wl," +
                    "--rpath={Root}{libs} -ldl\n").format(
                    ld=LD, opts=OPTS, binary=BASE, args=COMPIL_OPT,
                    Root=PROJECT_ROOT,libs=MEMORYDUMP))
            f.flush()
            safe_system(("{ld} @{tempfile}".format(tempfile=f.name, ld=LD)))
        safe_system(("{root}/staticpatcher.py {dump_dir}/lel_bin {binary} " +
                    "{loop}/{invocation}").format(root=ROOT, dump_dir=DIR,
                    binary=BASE, loop=LOOP, invocation=INVOCATION))

#in original mode
def original_fun(mode_opt, BASE, COMPIL_OPT, MODE):
    '''
    Original mode
    Call LoopInstrumentation on wanted loops
    by passing options like --invocation
    '''
    if MODE=="compilation":
        instru_opts = ""
        extract_opts = ""
        if(mode_opt.region):
            instru_opts = instru_opts + "--instrument-loop=" + mode_opt.region + " "
            if(mode_opt.regions_file):
                fail_lec("--regions-file and --region are incompatible")
            if(mode_opt.trace):
                print "Trace mode"
                instru_opts = instru_opts + "--loop-to-trace=" + mode_opt.region + " "
            if(mode_opt.instrument_app):
                fail_lec("--instrument-app and --region are incompatible")
        else:
            if(mode_opt.regions_file):
                instru_opts = instru_opts + "--loops-file=" + mode_opt.regions_file + " "
                if(mode_opt.instrument_app):
                    fail_lec("--instrument-app and --region-files are incompatible")
            else:
                if(mode_opt.instrument_app):
                    extract_opts = extract_opts + "--instrument-app "
                else:
                    instru_opts = instru_opts + "--instrument-app "
            if(mode_opt.trace):
                fail_lec("trace only with --loop ")
        if(mode_opt.nested_regions):
            instru_opts = instru_opts + "--nested-loops=true "
            if(mode_opt.no_nested_regions):
                fail_lec("can't --nested-regions and --no-nested-regions")
        else:
            if(mode_opt.no_nested_regions):
                instru_opts = instru_opts + "--nested-loops=false "
        if(mode_opt.instrument):
            if(mode_opt.instrument_app):
                safe_system(("{llvm_bindir}/opt -S -load {Root}{LoopExt} -loop-extract-all {opts} " +
                    "{base}.ll -o {base}.ll").format(llvm_bindir=LLVM_BINDIR, Root=PROJECT_ROOT,
                    LoopExt=LOOP_EXT, opts=extract_opts, base=BASE), EXIT=False)
            else:
                safe_system(("{llvm_bindir}/opt -S -load {Root}{LoopInstr} " +
                            "-vivo-loop-instrumentation {opts} {base}.ll " +
                            "-o {base}.ll").format(
                            llvm_bindir=LLVM_BINDIR, Root=PROJECT_ROOT,
                            LoopInstr=LOOP_INSTR, opts=instru_opts, base=BASE, EXIT=False))
        else:
            if(mode_opt.trace):
                fail_lec("--trace requires --intrument")
    else:
        if(mode_opt.instrument_app):
            safe_system(("{ld} -o {binary} {opts} {libs}").format(ld=LD,
                    binary=BASE, opts=COMPIL_OPT, libs=PROFILE_LIB))
        elif(mode_opt.instrument):
            safe_system(("{ld} -o {binary} {opts} {libs}").format(ld=LD,
                    binary=BASE, opts=COMPIL_OPT, libs=PROJECT_ROOT+RDTSC))
        else:
            safe_system(("{ld} -o {binary} {opts}").format(ld=LD,
                    binary=BASE, opts=COMPIL_OPT))

#Initialize Includes parser
class IncludeAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        namespace.Inc = (namespace.Inc + [option_string + values])

def init_parser_incl(parser, liste):
    parser.set_defaults(Inc=[])
    for j in liste:
        parser.add_argument(j, action=IncludeAction)

# initialize subparsers
def init_subpars(parser, region_required):
    parser.add_argument('--region', action=OptAction, required=region_required)
    parser.add_argument('--regions-file', action=OptAction)
    parser.add_argument('--invocation', action=OptAction)
    parser.add_argument('--trace', action=OptAction, nargs=0,
                        const=True, default=False)
    parser.add_argument('--instrument', action=OptAction, nargs=0,
                        const=True, default=False)
    parser.add_argument('--nested-regions', action=OptAction, nargs=0,
                        const=True, default=False)
    parser.add_argument('--no-nested-regions', action=OptAction, nargs=0,
                        const=True, default=False)
    parser.add_argument('--instrument-app', action=OptAction, nargs=0,
                        const=True, default=False)
    parser.add_argument('-o')
    parser.add_argument('-c', action=OptAction, nargs=0,
                        const=True, default=False)

def init_parser_core(parser):
    '''
    initialize main parser
    Create Subparsers for dump replay and original mode and
    manage version
    '''
    parser.add_argument('--version', '-v', action='version',
                        version='%(prog)s '+VERSION)
    subparsers = parser.add_subparsers(help='sub-command help')
    parser_dump = subparsers.add_parser('dump', description='dump')
    init_subpars(parser_dump, False)
    parser_dump.set_defaults(func=dump_fun)
    parser_replay = subparsers.add_parser('replay', description='replay')
    init_subpars(parser_replay, True)
    parser_replay.set_defaults(func=replay_fun)
    parser_instrument = subparsers.add_parser('original',
                                              description='original')
    init_subpars(parser_instrument, False)
    parser_instrument.set_defaults(func=original_fun)

def first_compil(INCLUDES, SOURCE, BASE, ext, COMPIL_OPT):
    '''
    First Compilation
    Detect source language (fortran or C/C++ for the moment)
    and compile SOURCE code
    '''
    if ext in FORTRAN_EXTENSIONS:
        if DRAGONEGG_PATH:
            safe_system(("{ld} {opts} -O0 -g {includes} {source} -S " +
                        "-fplugin={dragonegg} -fplugin-arg-dragonegg-emit-ir -o {base}.ll").format(
                        ld=LD, opts=" ".join(COMPIL_OPT), includes=" ".join(INCLUDES), source=SOURCE,
                        Root=PROJECT_ROOT, dragonegg=DRAGONEGG_PATH, base=BASE))
        else:
            fail_lec("fortran support disabled. Please reconfigure using --with-dragonegg.")
    else:
        safe_system(("{llvm_bindir}/clang {opts} -O0 -g {includes} {source} -S -emit-llvm -o " +
                    "{base}.ll").format(llvm_bindir=LLVM_BINDIR, opts=" ".join(COMPIL_OPT), includes=" ".join(INCLUDES),
                    source=SOURCE, base=BASE))

def last_compil(INCLUDES, SOURCE, BASE, OBJECT, COMPIL_OPT):
    '''
    Last Compilation
    Compile BASE.ll
    If Error compile with INCLUDES
    '''
    test = os.system("{llvm_bindir}/clang -c {opts} {base}.ll -o {object}".format(
                     llvm_bindir=LLVM_BINDIR, opts=" ".join(COMPIL_OPT), base=BASE, object=OBJECT))
    if (test):
        safe_system("{llvm_bindir}/clang -c {opts} {includes} {source} -o {object}".format(
                    llvm_bindir=LLVM_BINDIR, opts=" ".join(COMPIL_OPT), includes=" ".join(INCLUDES),
                    source=SOURCE, base=BASE, object=OBJECT))

def main():
    '''
    Main function
    '''
    # Create parsers
    parser = MyParser()
    # This second parser don't remove prefix matching
    # Args as -Iarg will recognyze by this parser
    incl_parser = argparse.ArgumentParser()
    init_parser_core(parser)
    init_parser_incl(incl_parser, ["-I", "-D"])

    #Parse args
    args = parser.parse_known_args()
    args2 = incl_parser.parse_known_args(args[1])

    #Source files must be detected better 
    if args[0].c:
        SOURCES = []
        MODE = "compilation"
        if (len(args2[1]) == 0):
            exit("Error:Need source file")
        INCLUDES = args2[0].Inc
        COMPIL_OPT = []
        for source in args2[1]:
            if os.path.splitext(source)[1] in SOURCE_EXTENSIONS:
                SOURCES.append(source)
            else: COMPIL_OPT.append(source)

        for SOURCE in SOURCES:
            BASE, ext = os.path.splitext(SOURCE)
            OBJECT = args[0].o if args[0].o else BASE + '.o'
            # call mode_function
            first_compil(INCLUDES, SOURCE, BASE, ext, COMPIL_OPT)
            args[0].func(args[0], BASE, "dummy_opt", MODE)
            last_compil(INCLUDES, SOURCE, BASE, OBJECT, COMPIL_OPT)
    else:
        MODE = "link"
        if (len(args[1]) == 0):
            exit("Error:Need source file")
        COMPIL_OPT = " ".join(args[1])
        BINARY = args[0].o
        # call mode_function
        args[0].func(args[0], BINARY, COMPIL_OPT, MODE)

if __name__ == "__main__":
    main()

