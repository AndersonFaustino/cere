#!/usr/bin/env python
# Loop Extractor Compiler
# (C) 2013 University of Versailles
import os
import argparse


#to ignore prefix matching
class MyParser(argparse.ArgumentParser):
    def _get_option_tuples(self, option_string):
        return []

ROOT = os.path.dirname(os.path.realpath(__file__))
PROJECT_ROOT = os.path.dirname(os.path.realpath(__file__+"/../.."))
LOOP_EXT = "/src/LoopExtractorAll/.libs/libLoopExtractorAll.so"
LOOP_MANAGE = "/src/LoopManager/.libs/libLoopManager.so"
LOOP_INSTR = "/src/LoopInstrumentation/.libs/libLoopInstrumentation.so"
VERSION = "@PACKAGE_VERSION@"
LLVM_BINDIR = "@LLVM_BINDIR@"
DRAGONEGG_PATH = "@DRAGONEGG_PATH@"

#Allowed options
option_forbidden = set([("dump", "--trace"),
                       ("dump", "--instrument"),
                       ("dump", "--nested-regions"),
                       ("dump", "--no-nested-regions"),
                       ("dump", "--instrument-app"),
                       ("replay", "--regions-file"),
                       ("replay", "--nested-regions"),
                       ("replay", "--no-nested-regions"),
                       ("replay", "--instrument-app"),
                       ("original", "--invocation")])


#Allowed option verification
class OptAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        if (parser.description, option_string) in option_forbidden:
            exit("Error:can't {option} in {mode} mode".format(
                 option=option_string, mode=parser.description))
        else:
            if (self.const):
                setattr(namespace, self.dest, self.const)
            else:
                setattr(namespace, self.dest, values)


def fail_lec(error_message):
    exit("Error {prog} : {cmd}".format(prog='lec', cmd=error_message))


def safe_system(command, EXIT=True):
    '''
    Try-catch system call
    Verify system call and exit with appropriate error message
    '''
    if(os.system(command)):
        if (EXIT):
            fail_lec("safe_system -> " + command)
        else:
            print("Warning Error {prog} : safe_system -> {cmd}".format(
                  prog='lec', cmd=command))


def dump_fun(mode_opt, BASE):
    '''
    Dump mode
    Call LoopExtractor and LoopManager in dump mode on wanted loops
    by passing options like --invocation
    '''
    temp = ""
    print "Compiling dump mode"
    if(mode_opt.region):
        temp = temp+"--loop-to-dump="+mode_opt.region+" "
        if(mode_opt.regions_file):
            fail_lec("--regions-file and --region are incompatible")
    else:
        if(mode_opt.regions_file):
            temp = temp+"--loops-file="+mode_opt.regions_file+" "
    if(mode_opt.invocation):
        temp = temp+"--invocation="+mode_opt.invocation+" "
    safe_system(("{llvm_bindir}/opt -S -load {Root}{LoopExt} -loop-extract-all " +
                "{base}.ll -o {base}.ll").format(llvm_bindir=LLVM_BINDIR, Root=PROJECT_ROOT,
                LoopExt=LOOP_EXT, base=BASE), EXIT=False)
    safe_system(("{llvm_bindir}/opt -S -load {Root}{LoopMan} -loop-dump {opts} " +
                "{base}.ll -o {base}.ll").format(llvm_bindir=LLVM_BINDIR, Root=PROJECT_ROOT,
                LoopMan=LOOP_MANAGE, opts=temp, base=BASE), EXIT=False)


#in replay mode
def replay_fun(mode_opt, BASE):
    '''
    Replay mode
    Call LoopExtractor and LoopManager in replay mode on wanted loop
    by passing options like --invocation
    '''
    temp = ""
    if (not (mode_opt.region)):
        fail_lec("Need --region with replay mode")
    print "Compiling replay mode"
    if (mode_opt.invocation):
        temp = temp + "--invocation=" + mode_opt.invocation + " "
    safe_system(("{llvm_bindir}/opt -S -load {Root}{LoopExt} -loop-extract-all " +
                "-isolate-loop={loop} {base}.ll -o {base}.ll").format(
                llvm_bindir=LLVM_BINDIR, Root=PROJECT_ROOT, LoopExt=LOOP_EXT,
                loop=mode_opt.region, base=BASE), EXIT=False)
    safe_system(("{llvm_bindir}/opt -S -load {Root}{LoopMan} -loop-replay {opts} " +
                "{base}.ll -o {base}.ll").format(llvm_bindir=LLVM_BINDIR,
                    Root=PROJECT_ROOT, LoopMan=LOOP_MANAGE, opts=temp,
                    base=BASE), EXIT=False)
    if (mode_opt.instrument):
        print "Instrumentation mode"
        temp_instr = "--instrument-loop=" + mode_opt.region + " "
        if(mode_opt.trace):
            print "Trace mode"
            temp_instr = (temp_instr + "--loop-to-trace="
                          + mode_opt.region + " ")
        safe_system(("{llvm_bindir}/opt -S -loop-simplify {base}.ll -o {base}.ll").format(
                    llvm_bindir=LLVM_BINDIR,
                    base=BASE), EXIT=False)
        safe_system(("{llvm_bindir}/opt -S -load {Root}{LoopInstr} " +
                    "-vitro-loop-instrumentation {opts} {base}.ll " +
                    "-o {base}.ll").format(
                    llvm_bindir=LLVM_BINDIR, Root=PROJECT_ROOT,
                    LoopInstr=LOOP_INSTR, opts=temp_instr, base=BASE),
                    EXIT=False)


#in original mode
def original_fun(mode_opt, BASE):
    '''
    Original mode
    Call LoopInstrumentation on wanted loops
    by passing options like --invocation
    '''
    temp = ""
    print "Instrumentation mode"
    if(mode_opt.region):
        temp = temp + "--instrument-loop=" + mode_opt.region + " "
        if(mode_opt.regions_file):
            fail_lec("--regions-file and --region are incompatible")
        if(mode_opt.trace):
            print "Trace mode"
            temp = temp + "--loop-to-trace=" + mode_opt.region + " "
        if(mode_opt.instrument_app):
            fail_lec("--instrument-app and --region are incompatible")
    else:
        if(mode_opt.regions_file):
            temp = temp + "--loops-file=" + mode_opt.regions_file + " "
            if(mode_opt.instrument_app):
                fail_lec("--instrument-app and --region-files are incompatible")
        else:
            if(mode_opt.instrument_app):
                temp = temp + "--instrument-app "
        if(mode_opt.trace):
            fail_lec("trace only with --loop ")
    if(mode_opt.nested_regions):
        temp = temp+"--nested-loops=true "
        if(mode_opt.no_nested_regions):
            fail_lec("can't --nested-regions and --no-nested-regions")
    else:
        if(mode_opt.no_nested_regions):
            temp = temp+"--nested-loops=false "
    if(mode_opt.instrument):
        safe_system(("{llvm_bindir}/opt -S -loop-simplify {base}.ll -o {base}.ll").format(
                    llvm_bindir=LLVM_BINDIR, base=BASE, EXIT=False))
        safe_system(("{llvm_bindir}/opt -S -load {Root}{LoopInstr} " +
                    "-vivo-loop-instrumentation {opts} {base}.ll " +
                    "-o {base}.ll").format(
                    llvm_bindir=LLVM_BINDIR, Root=PROJECT_ROOT,
                    LoopInstr=LOOP_INSTR, opts=temp, base=BASE, EXIT=False))
    else:
        if(mode_opt.trace):
            fail_lec("--trace requires --intrument")


#Initialize Includes parser
class IncludeAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        namespace.Inc = (namespace.Inc + [option_string + values])


def init_parser_incl(parser, liste):
    parser.set_defaults(Inc=[])
    for j in liste:
        parser.add_argument(j, action=IncludeAction)


# initialize subparsers
def init_subpars(parser, region_required):
    parser.add_argument('--region', action=OptAction, required=region_required)
    parser.add_argument('--regions-file', action=OptAction)
    parser.add_argument('--invocation', action=OptAction)
    parser.add_argument('--trace', action=OptAction, nargs=0,
                        const=True, default=False)
    parser.add_argument('--instrument', action=OptAction, nargs=0,
                        const=True, default=False)
    parser.add_argument('--nested-regions', action=OptAction, nargs=0,
                        const=True, default=False)
    parser.add_argument('--no-nested-regions', action=OptAction, nargs=0,
                        const=True, default=False)
    parser.add_argument('--instrument-app', action=OptAction, nargs=0,
                        const=True, default=False)
    parser.add_argument('-o')


def init_parser_core(parser):
    '''
    initialize main parser
    Create Subparsers for dump replay and original mode and
    manage version
    '''
    parser.add_argument('--version', '-v', action='version',
                        version='%(prog)s '+VERSION)
    subparsers = parser.add_subparsers(help='sub-command help')
    parser_dump = subparsers.add_parser('dump', description='dump')
    init_subpars(parser_dump, False)
    parser_dump.set_defaults(func=dump_fun)
    parser_replay = subparsers.add_parser('replay', description='replay')
    init_subpars(parser_replay, True)
    parser_replay.set_defaults(func=replay_fun)
    parser_instrument = subparsers.add_parser('original',
                                              description='original')
    init_subpars(parser_instrument, False)
    parser_instrument.set_defaults(func=original_fun)



def first_compil(INCLUDES, SOURCE, BASE, ext):
    '''
    First Compilation
    Detect source language (fortran or C/C++ for the moment)
    and compile SOURCE code
    '''
    if ((ext == ".f") or (ext == ".f90") or (ext == ".F") or (ext == ".F90")):
        if DRAGONEGG_PATH:
            safe_system(("gcc-4.7 -O0 -g -c {includes} {source} -S " +
                        "-fplugin={dragonegg} -fplugin-arg-dragonegg-emit-ir -o {base}.ll").format(
                        includes=" ".join(INCLUDES), source=SOURCE,
                        Root=PROJECT_ROOT, dragonegg=DRAGONEGG_PATH, base=BASE))
        else:
            fail_lec("fortran support disabled. Please reconfigure using --with-dragonegg.")

    else:
        safe_system(("{llvm_bindir}/clang -O0 -g -c {includes} {source} -S -emit-llvm -o " +
                    "{base}.ll").format(llvm_bindir=LLVM_BINDIR, includes=" ".join(INCLUDES),
                    source=SOURCE, base=BASE))


def last_compil(INCLUDES, SOURCE, BASE, OBJECT, COMPIL_OPT):
    '''
    Last Compilation
    Compile BASE.ll
    If Error compile with INCLUDES
    '''

    test = os.system("{llvm_bindir}/clang -c {opts} {base}.ll -o {object}".format(
                     llvm_bindir=LLVM_BINDIR, opts=" ".join(COMPIL_OPT), base=BASE, object=OBJECT))
    if (test):
        safe_system("{llvm_bindir}/clang -c {opts} {includes} {source} -o {object}".format(
                    llvm_bindir=LLVM_BINDIR, opts=" ".join(COMPIL_OPT), includes=" ".join(INCLUDES),
                    source=SOURCE, base=BASE, object=OBJECT))


def main():
    '''
    Main function
    '''
    # Create parsers
    parser = MyParser()
    # This second parser don't remove prefix matching
    # Args as -Iarg will recognyze by this parser
    incl_parser = argparse.ArgumentParser()
    init_parser_core(parser)
    init_parser_incl(incl_parser, ["-I", "-D"])

    #Parse args
    args = parser.parse_known_args()
    args2 = incl_parser.parse_known_args(args[1])
    if (len(args2[1]) == 0):
        exit("Error:Need source file")
    INCLUDES = args2[0].Inc
    COMPIL_OPT = args2[1]
    SOURCE = COMPIL_OPT[-1]
    COMPIL_OPT.remove(SOURCE)
    BASE, ext = os.path.splitext(SOURCE)
    OBJECT = args[0].o if args[0].o else BASE + '.o'
    first_compil(INCLUDES, SOURCE, BASE, ext)
    # call mode_function
    args[0].func(args[0], BASE)
    last_compil(INCLUDES, SOURCE, BASE, OBJECT, COMPIL_OPT)


if __name__ == "__main__":
    main()

