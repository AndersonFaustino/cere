#!/usr/bin/env python
# Loop Extractor Compiler
# (C) 2013 University of Versailles
import os
import argparse


#to ignore prefix matching
class MyParser(argparse.ArgumentParser):
    def _get_option_tuples(self, option_string):
        return []

ROOT = os.path.dirname(os.path.realpath(__file__))
PROJECT_ROOT = os.path.dirname(os.path.realpath(__file__+"/../.."))
RDTSC = "/src/rdtsc/librdtsc.a"
MEMORYDUMP = "/src/memory_dump/.libs/"
VERSION = "@PACKAGE_VERSION@"
LD="gcc-4.7"


#Allowed options
option_forbidden = set([("dump", "--trace"),
                       ("dump", "--instrument"),
                       ("dump", "--nested-regions"),
                       ("dump", "--no-nested-regions"),
                       ("dump", "--instrument-app"),
                       ("replay", "--regions-file"),
                       ("replay", "--nested-regions"),
                       ("replay", "--no-nested-regions"),
                       ("replay", "--instrument-app"),
                       ("original", "--invocation")])



#Allowed option verification
class OptAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        if (parser.description, option_string) in option_forbidden:
            exit("Error:can't {option} in {mode} mode".format(
                 option=option_string, mode=parser.description))
        else:
            if (self.const):
                setattr(namespace, self.dest, self.const)
            else:
                setattr(namespace, self.dest, values)


def fail_lel(error_message):
    exit("Error {prog} : {cmd}".format(prog='lel', cmd=error_message))


def safe_system(command):
    '''
    Try-catch system call
    Verify system call and exit with appropriate error message
    '''
    if(os.system(command)):
        fail_lel("safe_system -> " + command)


def user_main(FILE, LOOP, instrument):
    # Define by default TIMEOUT_SECONDS to 60
    TIMEOUT_SECONDS=os.getenv('TIMEOUT_SECONDS', 60) #1min is probably enough
    # Define by default CALL_COUNT to 11
    INVITRO_CALL_COUNT=os.getenv('INVITRO_CALL_COUNT', 11)
    if (instrument):
        temp = "likwid_markerInit();\n"
    else:
        temp=""
    TEMPLATE = open("{root}/Template_realmain.c".format(root=ROOT), "r")
    template = TEMPLATE.read()
    TEMPLATE.close()
    FILE.write(template.format(time_out=TIMEOUT_SECONDS, likwid=temp,
               in_vitro_call_count=INVITRO_CALL_COUNT,
               loop=LOOP.replace("-","_")))


def create_user_main(Instrument,LOOP):
    safe_system("rm -f realmain.c")
    MAIN=open('realmain.c','w')
    user_main(MAIN, LOOP, Instrument)
    MAIN.close()


def compile_memory_dump_objects(DIR):
    DUMP_ARGS="-Wl,--section-start=.text=0x60000000"
    safe_system("rm -f dump/objs.S")
    OBJ=open("dump/objs.S",'w')
    for FILE in os.listdir(DIR):
        BASE, ext = os.path.splitext(FILE)
        FILE = DIR+"/"+FILE
        if (ext=='.memdump'):
            OBJ.write((".section s{n}, \"aw\"\n" +
                       ".incbin \"{m}\"\n").format(n=BASE,m=FILE))
            DUMP_ARGS = (DUMP_ARGS +
                        " -Wl,--section-start=s{n}=0x{n}".format(n=BASE))
    OBJ.close()
    safe_system(LD + " -c dump/objs.S")
    return DUMP_ARGS


def dump_fun(mode_opt, BINARY, COMPIL_OPT):
    '''
    Dump mode
    Call the linker and copy the original binary
    '''
    safe_system(("{ld} {opts} -o {binary} -L {Root}{libs} -ldump -Wl," +
                "--rpath={Root}{libs} -ldl").format(ld=LD, binary=BINARY,
                opts=COMPIL_OPT, Root=PROJECT_ROOT,libs=MEMORYDUMP))

#in replay mode
def replay_fun(mode_opt, BINARY, COMPIL_OPT):
    '''
    Replay mode
    Create Realmain and call the linker
    '''
    LOOP=mode_opt.region
    INVOCATION=mode_opt.invocation
    if (mode_opt.instrument):
        COMPIL_OPT = PROJECT_ROOT + RDTSC + " " + COMPIL_OPT
    if(not INVOCATION):
        INVOCATION=1
    DIR="dump/{loop}/{invocation}".format(loop=LOOP,invocation=INVOCATION)
    # Check that dumps exists
    if (not os.path.isdir(DIR)):
        fail_lel("No dump for {loop} invocation {invocation}".format(loop=LOOP,
                 invocation=INVOCATION))
    # Compress the traces
    safe_system("{root}/compress.py {rep}/".format(root=ROOT, rep=DIR))
    create_user_main(mode_opt.instrument,LOOP)
    safe_system(LD + " -c realmain.c")
    OPTS = compile_memory_dump_objects(DIR)
    safe_system(("{ld} {opts} -o {binary} objs.o realmain.o {args} " +
                "-L {Root}{libs} -lload -Wl," +
                "--rpath={Root}{libs} -ldl").format(
                ld=LD, opts=OPTS, binary=BINARY, args=COMPIL_OPT,
                Root=PROJECT_ROOT,libs=MEMORYDUMP))
    safe_system(("{root}/staticpatcher.py {dump_dir}/lel_bin {binary} " +
                "{loop}/{invocation}").format(root=ROOT, dump_dir=DIR,
                binary=BINARY, loop=LOOP, invocation=INVOCATION))


#in original mode
def original_fun(mode_opt, BINARY, COMPIL_OPT):
    '''
    Original mode
    Only call the linker
    '''
    safe_system(("{ld} {opts} -o {binary} {Root}{libs}").format(ld=LD,
                binary=BINARY, opts=COMPIL_OPT, Root=PROJECT_ROOT,libs=RDTSC))


# initialize subparsers
def init_subpars(parser, region_required):
    parser.add_argument('--region', action=OptAction, required=region_required)
    parser.add_argument('--regions-file', action=OptAction)
    parser.add_argument('--invocation', action=OptAction)
    parser.add_argument('--trace', action=OptAction, nargs=0,
                        const=True, default=False)
    parser.add_argument('--instrument', action=OptAction, nargs=0,
                        const=True, default=False)
    parser.add_argument('--nested-regions', action=OptAction, nargs=0,
                        const=True, default=False)
    parser.add_argument('--no-nested-regions', action=OptAction, nargs=0,
                        const=True, default=False)
    parser.add_argument('--instrument-app', action=OptAction, nargs=0,
                        const=True, default=False)
    parser.add_argument('-o', required=True)


def init_parser_core(parser):
    '''
    initialize main parser
    Create Subparsers for dump replay and original mode and
    manage version
    '''
    parser.add_argument('--version', '-v', action='version',
                        version='%(prog)s '+VERSION)
    subparsers = parser.add_subparsers(help='sub-command help')
    parser_dump = subparsers.add_parser('dump', description='dump')
    init_subpars(parser_dump, False)
    parser_dump.set_defaults(func=dump_fun)
    parser_replay = subparsers.add_parser('replay', description='replay')
    init_subpars(parser_replay, True)
    parser_replay.set_defaults(func=replay_fun)
    parser_instrument = subparsers.add_parser('original',
                                              description='original')
    init_subpars(parser_instrument, False)
    parser_instrument.set_defaults(func=original_fun)


def main():
    '''
    Main function
    '''
    # Create parsers
    parser = MyParser()
    init_parser_core(parser)
    #Parse args
    args = parser.parse_known_args()
    if (len(args[1]) == 0):
        exit("Error:Need source file")
    COMPIL_OPT = " ".join(args[1])
    BINARY = args[0].o
    # call mode_function
    args[0].func(args[0], BINARY, COMPIL_OPT)


if __name__ == "__main__":
    main()

