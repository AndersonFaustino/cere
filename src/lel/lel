#!/bin/bash
# Loop Extractor Linker
# (C) 2013 University of Versailles

ROOT="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PROJECT_ROOT="$ROOT/../../"

LD=gcc-4.7

# parse arguments
if [[ $1 == --replay=* ]]; then
    SPLIT=(${1//=/ })
    REPLAY_LOOP=${SPLIT[1]}
    echo "Linking with <$REPLAY_LOOP> memory dump" > /dev/stderr
    shift
    if [[ $1 =~ --invocation=* ]]; then
        REPLAY_OPTS=(${1//=/ })
        INVOCATION=${REPLAY_OPTS[1]}
        shift
    else
        INVOCATION=1
    fi
    echo "Invocation <$INVOCATION>" > /dev/stderr
fi

if [[ $1 == --dump ]]; then
    DUMP_MODE=1
    # lel ignores dump mode (nothing special to do)
    shift
    if [[ $1 =~ --loop-to-dump=* ]] || [[ $1 =~ --loops-file=* ]]; then
        shift
    fi
    if [[ $1 =~ --invocation=* ]]; then
        shift
    fi
fi

if [[ $1 == --instrument ]]; then
    INSTRUMENT=1
    echo "Instrumentation mode" > /dev/stderr
    shift
    if [[ $1 =~ --instrument-loop=* ]] || [[ $1 =~ --loops-file=* ]]; then
        #The linker ignores instrumentation options
        shift
    fi
    if [[ $1 =~ --loop-to-trace=* ]]; then
        #The linker ignores instrumentation options
        shift
    fi
fi

ARGS=$*
#If we want to instrument, link with rdtsc lib
if [[ ! -z "$INSTRUMENT" ]]; then
    ARGS="$ARGS $PROJECT_ROOT/src/rdtsc/librdtsc.a"
fi
if [[ ! -z "$DUMP_MODE" ]]; then
    ARGS="$ARGS -L $PROJECT_ROOT/src/memory_dump/.libs/ -ldump -Wl,--rpath=$PROJECT_ROOT/src/memory_dump/.libs/ -ldl"
fi
if [[ ! -z "$REPLAY_LOOP" ]]; then
    ARGS="$ARGS $PROJECT_ROOT/src/memory_dump/libload.a"
fi

if [[ -z "$REPLAY_LOOP" ]]; then
    while [ ! "$1" = "-o" ]
    do
        shift
    done
    # In normal mode, just call the linker
    echo $LD $ARGS
    $LD $ARGS
    if [[ ! -z "$DUMP_MODE" ]]; then #Copy the original binary
        cp "$2" lel_bin
    fi
else
    # Check that dumps exists
    if [ ! -d "dump/${REPLAY_LOOP}/${INVOCATION}" ]; then
        echo "No dump for ${REPLAY_LOOP} invocation ${INVOCATION}" > /dev/stderr
        exit -1
    fi

    # Compress the traces
    echo $ROOT/compress.py dump/${REPLAY_LOOP}/${INVOCATION}/
    $ROOT/compress.py dump/${REPLAY_LOOP}/${INVOCATION}/

    # Define by default TIMEOUT_SECONDS to 60
    if [[ -z "$TIMEOUT_SECONDS" ]]; then
        TIMEOUT_SECONDS=60 #1min is probably enough
    fi

    # Define by default CALL_COUNT to 11
    if [[ -z "$INVITRO_CALL_COUNT" ]]; then
        INVITRO_CALL_COUNT=11
    fi

    # Create user main
    rm -f realmain.c
    if [[ ! -z "$INSTRUMENT" ]]; then #We want to instrument
        echo "#include <stdlib.h>" > realmain.c
        echo "#include <stdio.h>" >> realmain.c
        echo "#include <signal.h>" >> realmain.c
        echo "#include <assert.h>" >> realmain.c
        echo "void anti_dead_code_elimination(int n, ...) {}" >> realmain.c
        echo "void sigcatch(int signal) {
        fprintf(stderr, \"Timeout...\n\");
        exit(EXIT_FAILURE);
        }" >> realmain.c
        echo "
        static void
        sigsegv_handler(int sig, siginfo_t *si, void *unused)
        {
          char * touched_addr = si->si_addr;
          printf(\"Detected segfault at: %p\n\", touched_addr);
          printf(\"Dumping process memory map\n\");
          printf(\"==========================\n\");
          char cmd[255];
          pid_t pid = getpid();
          snprintf(cmd, sizeof(cmd), \"cat /proc/%d/maps\", pid);
          system(cmd);
          printf(\"==========================\n\");
          exit(EXIT_FAILURE);
        }

        void real_main(int empty) {
        int i;
        //kill program after 10 minutes
        long long int max_seconds=10*$TIMEOUT_SECONDS;

        struct sigaction sa;
        sa.sa_flags = SA_SIGINFO;
        sigemptyset(&sa.sa_mask);
        sa.sa_sigaction = sigsegv_handler;
        int res = sigaction(SIGSEGV, &sa, NULL);
        assert(res != -1);

        signal(SIGALRM, sigcatch);
        likwid_markerInit();
        for(i=0; i<$INVITRO_CALL_COUNT; i++) {
          alarm(max_seconds);
          run${REPLAY_LOOP/-/_}();
        }
        exit(0);
        }" >> realmain.c
    else #We don't want to instrument
        echo "#include <stdlib.h>" > realmain.c
        echo "void anti_dead_code_elimination(int n, ...) {}" >> realmain.c
        echo "void real_main() {
        run${REPLAY_LOOP/-/_}();
        exit(0);
        }" >> realmain.c
    fi
    gcc-4.7 -c realmain.c


    # 0x60000000 is chosen to allocate at least 1.5GB for the heap
    # If a dump file is larger than 1.5GB we cannot support it
    #
    # Sometimes (NAS BT for instance) this requires compiling the code with
    # -mcmodel=large to allow relocation longer than 2GB
    DUMP_ARGS="-Wl,--section-start=.text=0x60000000"
    # First compile the memory dump objects
    rm -f dump/objs.S
    for m in dump/$REPLAY_LOOP/$INVOCATION/*.memdump; do
        n=`basename $m .memdump`
        echo ".section s$n, \"aw\"" >> dump/objs.S
        echo ".incbin \"$m\"" >> dump/objs.S
        DUMP_ARGS="$DUMP_ARGS -Wl,--section-start=s$n=0x$n"
    done
    gcc-4.7 -c dump/objs.S
    $LD $DUMP_ARGS objs.o realmain.o $ARGS
    while [ ! "$1" = "-o" ]
    do
        shift
    done
    $ROOT/staticpatcher.py lel_bin "$2" "${REPLAY_LOOP}/${INVOCATION}"
fi
