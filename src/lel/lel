#!/bin/bash
# Loop Extractor Linker
# (C) 2013 University of Versailles

ROOT="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PROJECT_ROOT="$ROOT/../../"

LD=gcc

# parse arguments
if [[ $1 == --replay=* ]]; then
    SPLIT=(${1//=/ })
    REPLAY_LOOP=${SPLIT[1]}
    echo "Linking with <$REPLAY_LOOP> memory dump" > /dev/stderr
    shift
fi 

if [[ $1 == --dump ]]; then
    DUMP_MODE=1
    # lel ignores dump mode (nothing special to do)
    shift
fi

if [[ $1 == --instrument ]]; then
    INSTRUMENT=1
    echo "Instrumentation mode" > /dev/stderr
    shift
fi

ARGS=$*
#If we want to instrument, link with rdtsc lib
if [[ ! -z "$INSTRUMENT" ]]; then
    ARGS="$ARGS $PROJECT_ROOT/src/rdtsc/rdtsc.a -lstdc++"
fi
if [[ ! -z "$DUMP_MODE" ]] || [[ ! -z "$REPLAY_LOOP" ]]; then
    cp $PROJECT_ROOT/src/memory_dump/dump.c .
    clang -c dump.c
    ARGS="$ARGS dump.o"
fi

if [[ -z "$REPLAY_LOOP" ]]; then
    while [ ! "$1" = "-o" ]
    do
        shift
    done
    # In normal mode, just call the linker
    $LD $ARGS
    if [[ ! -z "$DUMP_MODE" ]]; then #Copy the original binary
        cp "$2" lel_bin
    fi
else
    # Check that dumps exists
    if [ ! -d "dump/$REPLAY_LOOP" ]; then
        echo "No dump for $REPLAY_LOOP" > /dev/stderr
        exit -1
    fi
    #we need to know the number of cycles
    #this loop takes in vivo
    #~ CYCLES=`grep ${REPLAY_LOOP/extracted/invivo} all_loops.csv | cut -d ',' -f 3`
    if [[ -z "$CYCLES" ]]; then
        CYCLES=60000000000 #1min is probably enough
    fi
    #How can we convert those cycles in seconds?
    # Create user main
    rm -f realmain.c
    if [[ ! -z "$INSTRUMENT" ]]; then #We want to instrument
        echo "#include <stdlib.h>" > realmain.c
        echo "#include <stdio.h>" >> realmain.c
        echo "#include <signal.h>" >> realmain.c
        echo "void sigcatch(int signal) {
        fprintf(stderr, \"Timeout...\n\");
        exit(EXIT_FAILURE);
        }" >> realmain.c
        echo "void real_main() {
        int i;
        long long int max_cycles=(10*$CYCLES)/1e9;
        signal(SIGALRM, sigcatch);
        likwid_markerInit();
        for(i=0; i<11; i++) {
          alarm(max_cycles);
          run${REPLAY_LOOP/-/_}();
        }
        likwid_markerClose();
        exit(0);
        }" >> realmain.c
    else #We don't want to instrument
        echo "#include <stdlib.h>" > realmain.c
        echo "void real_main() {
        run${REPLAY_LOOP/-/_}();
        exit(0);
        }" >> realmain.c
    fi
    gcc -c realmain.c


    # 0x60000000 is chosen to allocate at least 1.5GB for the heap
    # If a dump file is larger than 1.5GB we cannot support it
    #
    # Sometimes (NAS BT for instance) this requires compiling the code with
    # -mcmodel=large to allow relocation longer than 2GB
    DUMP_ARGS="-Wl,--section-start=.init_array=0x60000000"
    # First compile the memory dump objects
    rm -f dump/objs.S
    for m in dump/$REPLAY_LOOP/*.memdump; do
        n=`basename $m .memdump`
        echo ".section s$n, \"aw\"" >> dump/objs.S
        echo ".incbin \"$m\"" >> dump/objs.S
        DUMP_ARGS="$DUMP_ARGS -Wl,--section-start=s$n=0x$n"
    done
    gcc -c dump/objs.S 
    $LD $DUMP_ARGS objs.o realmain.o $ARGS 
    while [ ! "$1" = "-o" ]
    do
        shift
    done
    $ROOT/staticpatcher.py lel_bin "$2" $REPLAY_LOOP
fi
